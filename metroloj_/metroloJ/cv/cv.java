/**
 *
 *  cv v1, 11 oct. 2009
    Fabrice P Cordelieres, fabrice.cordelieres at gmail.com

    Copyright (C) 2009 Fabrice P. Cordelieres

    License:
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package metroloJ.cv;

import ij.IJ;
import ij.ImagePlus;
import ij.WindowManager;
import ij.gui.Plot;
import ij.gui.Roi;
import ij.gui.Toolbar;
import ij.io.FileSaver;
import ij.measure.Calibration;
import ij.measure.Measurements;
import ij.process.ImageProcessor;
import ij.process.ImageStatistics;
import java.awt.Color;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import metroloJ.utilities.tricks.dataTricks;
import metroloJ.utilities.tricks.fileTricks;
import metroloJ.utilities.tricks.imageTricks;

/**
 * Generates a CV (coefficient of variation) of an image/stack, considering each
 * slice as coming from a different PMT
 * @author fab
 */
public class cv implements Measurements{
    /** Stores the currently opened ImagePlus at cv creation **/
    public ImagePlus ip=null;

    /** Stores the number slices in the current image **/
    public int nImg=0;

    /** Stores the names of the images **/
    public String[] names;

    /** Stores the ROIs generated by the user during the cv creation process **/
    public Roi[] rois;

    /** Stores ImageStatistics for each user generated ROIs at cv creation **/
    public ImageStatistics[] stats;

    /** Stores the histograms **/
    public Vector<int[]> histograms;
    
    /** Stores the raw CVs calculated for each ROI **/
    public double[] cv;

    /** Stores the min CV **/
    public double minCV;

    /** Stores the current image's calibration **/
    public Calibration cal;

    /**
     * Starts the processs of creating a cv object on the current image
     */
    public cv(){
       ip=WindowManager.getCurrentImage();
       if (ip==null){
           IJ.error("Please, open an image first...");
           return;
       }

       nImg=ip.getNSlices();
       names=new String[nImg];
       rois=new Roi[nImg];
       stats=new ImageStatistics[nImg];
       histograms=new Vector<int[]>();
       cv=new double[nImg];

       cal=ip.getCalibration();
       ip.setCalibration(null);

       for (int i=0; i<nImg; i++){
           ip.killRoi();
           String defaultName=ip.getStack().getShortSliceLabel(i+1);
           while(!IJ.spaceBarDown() || rois[i]==null){
               IJ.setTool(Toolbar.RECTANGLE);
               ip.setSlice(i+1);
               IJ.showStatus((nImg==1?"":(defaultName==null?"Image"+(i+1):defaultName)+": ")+"Draw the ROI to evaluate, then press space bar");
               rois[i]=ip.getRoi();
           }
           names[i]=IJ.getString("Name for this image", defaultName==null?"Image"+(i+1):defaultName);
           rois[i].setName(names[i]);
           stats[i]=ip.getStatistics(AREA+MEAN+MIN_MAX+STD_DEV);
           if (ip.getBitDepth()==8){
               histograms.add(stats[i].histogram);
           }else{
               histograms.add(stats[i].histogram16);
           }
           cv[i]=stats[i].stdDev/stats[i].mean;
       }
       minCV=dataTricks.min(cv);
       ip.setCalibration(cal);
    }

    /**
     * Outputs the ROIs' histograms as a String
     * @return a string containing tab separated values of the ROIs histogram
     */
    public String histogramsToString(){
        String out="Intensity";
        
        for (int i=0; i<nImg; i++) out+="\tNb pixels ("+names[i]+")\n";
        
        for (int i=0; i<histograms.elementAt(0).length; i++){
            out+=i;
            for (int j=0; j<nImg; j++) out+="\t"+histograms.elementAt(j)[i];
            out+="\n";
        }
        
        return out;
    }
    
    /**
     * Outputs the CVs' table as a String
     * @return a string containing tab separated values of the ROIs statistics
     * (Standard deviation, Average, Nb pixels, CV and optionally CVs relative to PMT1)
     */
    public String tableToString(){
        String out="Standard deviation\tAverage\tNb pixels\tCV";
        
        if (nImg>1) out="\t"+out+"\tCVs relative to min value\n";
        
        for (int i=0; i<nImg; i++){
            String line=stats[i].stdDev+"\t"+stats[i].mean+"\t"+(int) stats[i].area+"\t"+cv[i];
            if (nImg>1) line=names[i]+"\t"+line+"\t"+(cv[i]/minCV)+"\n";
            out+=line;
        }
        
        return out;
    }

    /**
     * Saves a String to a text file
     * @param content the String to save
     * @param path the file to which the String will be saved
     */
    public void saveHistogramsTable(String path){
        try {
            BufferedWriter file = new BufferedWriter(new FileWriter(path));

            String out="Intensity";

            for (int i=0; i<nImg; i++) out+="\tNb pixels ("+names[i]+")";

            file.write(out+"\n");

            for (int i=0; i<histograms.elementAt(0).length; i++){
                out=""+i;
                for (int j=0; j<nImg; j++) out+="\t"+histograms.elementAt(j)[i];
                out+="\n";
                file.write(out);
            }

            file.close();
        } catch (IOException ex) {
            Logger.getLogger(cv.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * Formats the CV table to be directly used in the CVreport
     * @return a 2D array of String containing the CV table
     */
    public String[][] tableForReport(){
        String[][] out;
        
        if (nImg>1){
            out=new String[6][nImg+1];
        }else{
            out=new String[5][nImg+1];
        }

        out[0][0]="";
        out[1][0]="Standard deviation";
        out[2][0]="Average";
        out[3][0]="Nb pixels";
        out[4][0]="CV";
        if (nImg>1) out[5][0]="CVs relative to min value";

        for (int i=0; i<nImg; i++){
            out[0][i+1]=names[i];
            out[1][i+1]=""+dataTricks.round(stats[i].stdDev, 3);
            out[2][i+1]=""+dataTricks.round(stats[i].mean, 3);
            out[3][i+1]=""+(int) stats[i].area;
            out[4][i+1]=""+dataTricks.round(cv[i], 3);
            if (nImg>1) out[5][i+1]=""+dataTricks.round(cv[i]/minCV, 3);
        }
        return out;
    }

    /**
     * Generates the panel view containing all the PMTs' images with scale bars
     * and labels
     * @param barWidth the scale bar's width in microns
     * @return an ImagePlus containing the panel
     */
    public ImagePlus getPanel(int barWidth){
        ImagePlus ipCopy=imageTricks.copyCarbon(ip, null);
        int lineWidth=Math.max(2, ipCopy.getWidth()/200);
        for (int i=0; i<nImg; i++){
            ipCopy.setSlice(i+1);

            ImageProcessor iproc=ipCopy.getProcessor();
            iproc.setColorModel(iproc.getDefaultColorModel());
            iproc.setColor(Color.white);
            iproc.setLineWidth(lineWidth);
            iproc.draw(rois[i]);

            if (nImg>1) imageTricks.drawLabel(iproc, names[i]);
            imageTricks.addScaleBar(iproc, cal, imageTricks.BOTTOM_RIGHT,barWidth);
        }
        return imageTricks.makeMontage(ipCopy, nImg, ip.getWidth()/100);
    }

    /**
     * Generates an image containing the plots of the ROIs' histograms
     * @return an ImagePlus containing the plots of the ROIs' histograms
     */
    public ImagePlus getHistograms(){
        double xMin=dataTricks.findFirstNonZero(histograms.elementAt(0));
        double xMax=dataTricks.findLastNonZero(histograms.elementAt(0));
        double yMin=stats[0].area;
        double yMax=0;

        for (int i=0; i<nImg; i++){
            xMin=Math.min(xMin, dataTricks.findFirstNonZero(histograms.elementAt(i)));
            xMax=Math.max(xMax, dataTricks.findLastNonZero(histograms.elementAt(i)));
            for (int j=0; j<histograms.elementAt(i).length; j++){
                yMin=Math.min(yMin, histograms.elementAt(i)[j]);
                yMax=Math.max(yMax, histograms.elementAt(i)[j]);
            }
        }

        double[] x=new double[(int) Math.pow(2, ip.getBitDepth())];
        double[] y=new double[x.length];
        
        for (int i=0; i<x.length; i++){
            x[i]=i;
            y[i]=histograms.elementAt(0)[i];
        }
        
        Plot plot=new Plot("Histograms", "Gray levels", "Nb of pixels", x, y);
        plot.setLimits(xMin, xMax, yMin, yMax);
        plot.setSize(600, 400);
        plot.setColor(imageTricks.COLORS[0]);
        plot.draw();
        
        String label=imageTricks.COLOR_NAMES[0]+": "+names[0]+"\n";
        int colorIndex=1;
        
        if (nImg>1){
            for (int i=1; i<nImg; i++){
                for (int j=0; j<x.length; j++) y[j]=histograms.elementAt(i)[j];
                plot.setColor(imageTricks.COLORS[colorIndex]);
                plot.addPoints(x, y, Plot.LINE);
                label+=imageTricks.COLOR_NAMES[colorIndex++]+": "+names[i]+"\n";
                if (colorIndex>=imageTricks.COLORS.length) colorIndex=0;
            }
            plot.draw();
            plot.setColor(Color.black);
            plot.addLabel(0.6, 0.13, label);
        }
        return plot.getImagePlus();
    }

    /**
     * Saves all data generated during the CV analysis
     * @param path folder where the data should be saved
     * @param filename base name of data files
     * @param barWidth scale bar's width in microns
     */
    public void saveData(String path, String filename, int barWidth){
        FileSaver fs=new FileSaver(getPanel(barWidth));
        fs.saveAsJpeg(path+filename+"_panel.jpg");
        fs=new FileSaver(getHistograms());
        fs.saveAsJpeg(path+filename+(nImg==1?"_histogram.jpg":"_histograms.jpg"));
        saveHistogramsTable(path+filename+(nImg==1?"_histogram.xls":"_histograms.xls"));
        fileTricks.save(tableToString(), path+filename+(nImg==1?"_CV.xls":"_CVs.xls"));
        if(nImg==1){
            fileTricks.saveRoi(rois[0], path+names[0]+"_roi.roi");
        }else{
            fileTricks.saveRois(rois, path+filename+"_rois.zip");
        }
    }
}
